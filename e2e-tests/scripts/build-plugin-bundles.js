#!/usr/bin/env node

/**
 * Plugin Bundle Builder for MusicalConductor E2E Tests
 * 
 * This script automatically creates dist/plugin.js bundle files for all E2E test plugins
 * by copying their index.js files to the expected bundle location.
 * 
 * Usage:
 *   node scripts/build-plugin-bundles.js
 *   npm run build:plugins
 */

const fs = require('fs');
const path = require('path');

// Configuration
const PLUGINS_DIR = path.join(__dirname, '..', 'test-app', 'plugins');
const BUNDLE_FILENAME = 'plugin.js';
const SOURCE_FILENAME = 'index.js';

/**
 * Get all plugin directories
 */
function getPluginDirectories() {
  try {
    const items = fs.readdirSync(PLUGINS_DIR, { withFileTypes: true });
    return items
      .filter(item => item.isDirectory())
      .map(item => item.name);
  } catch (error) {
    console.error('‚ùå Error reading plugins directory:', error.message);
    process.exit(1);
  }
}

/**
 * Create bundle for a single plugin
 */
function createPluginBundle(pluginName) {
  const pluginDir = path.join(PLUGINS_DIR, pluginName);
  const sourceFile = path.join(pluginDir, SOURCE_FILENAME);
  const distDir = path.join(pluginDir, 'dist');
  const bundleFile = path.join(distDir, BUNDLE_FILENAME);

  // Check if source file exists
  if (!fs.existsSync(sourceFile)) {
    console.log(`‚ö†Ô∏è  Skipping ${pluginName}: No ${SOURCE_FILENAME} found`);
    return false;
  }

  try {
    // Create dist directory if it doesn't exist
    if (!fs.existsSync(distDir)) {
      fs.mkdirSync(distDir, { recursive: true });
      console.log(`üìÅ Created dist directory for ${pluginName}`);
    }

    // Read source file
    const sourceContent = fs.readFileSync(sourceFile, 'utf8');

    // Add bundle header comment
    const bundleHeader = `/**
 * Bundle for ${pluginName}
 * Generated automatically from ${SOURCE_FILENAME}
 * Build time: ${new Date().toISOString()}
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Edit the source file: ${SOURCE_FILENAME}
 * Then run: npm run build:plugins
 */

`;

    const bundleContent = bundleHeader + sourceContent;

    // Write bundle file
    fs.writeFileSync(bundleFile, bundleContent, 'utf8');
    
    console.log(`‚úÖ Built bundle for ${pluginName}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Error building bundle for ${pluginName}:`, error.message);
    return false;
  }
}

/**
 * Get file stats for comparison
 */
function getFileStats(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return {
      exists: true,
      size: stats.size,
      modified: stats.mtime
    };
  } catch {
    return { exists: false };
  }
}

/**
 * Check if bundle needs to be rebuilt
 */
function needsRebuild(pluginName) {
  const pluginDir = path.join(PLUGINS_DIR, pluginName);
  const sourceFile = path.join(pluginDir, SOURCE_FILENAME);
  const bundleFile = path.join(pluginDir, 'dist', BUNDLE_FILENAME);

  const sourceStats = getFileStats(sourceFile);
  const bundleStats = getFileStats(bundleFile);

  if (!sourceStats.exists) return false;
  if (!bundleStats.exists) return true;
  
  return sourceStats.modified > bundleStats.modified;
}

/**
 * Main build function
 */
function buildAllBundles(options = {}) {
  const { force = false, verbose = false } = options;
  
  console.log('üéº MusicalConductor Plugin Bundle Builder');
  console.log('==========================================');
  
  const pluginDirs = getPluginDirectories();
  
  if (pluginDirs.length === 0) {
    console.log('‚ö†Ô∏è  No plugin directories found');
    return;
  }

  console.log(`üìã Found ${pluginDirs.length} plugin directories`);
  
  let built = 0;
  let skipped = 0;
  let errors = 0;

  for (const pluginName of pluginDirs) {
    if (verbose) {
      console.log(`\nüîç Processing ${pluginName}...`);
    }

    if (!force && !needsRebuild(pluginName)) {
      if (verbose) {
        console.log(`‚è≠Ô∏è  Skipping ${pluginName}: Bundle is up to date`);
      }
      skipped++;
      continue;
    }

    const success = createPluginBundle(pluginName);
    if (success) {
      built++;
    } else {
      errors++;
    }
  }

  console.log('\nüìä Build Summary:');
  console.log(`   ‚úÖ Built: ${built}`);
  console.log(`   ‚è≠Ô∏è  Skipped: ${skipped}`);
  console.log(`   ‚ùå Errors: ${errors}`);
  
  if (errors > 0) {
    console.log('\n‚ö†Ô∏è  Some bundles failed to build. Check the errors above.');
    process.exit(1);
  } else {
    console.log('\nüéâ All plugin bundles built successfully!');
  }
}

/**
 * CLI interface
 */
function main() {
  const args = process.argv.slice(2);
  const options = {
    force: args.includes('--force') || args.includes('-f'),
    verbose: args.includes('--verbose') || args.includes('-v'),
  };

  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
MusicalConductor Plugin Bundle Builder

Usage: node build-plugin-bundles.js [options]

Options:
  --force, -f     Force rebuild all bundles (ignore timestamps)
  --verbose, -v   Show detailed output
  --help, -h      Show this help message

Examples:
  node build-plugin-bundles.js           # Build only changed plugins
  node build-plugin-bundles.js --force   # Rebuild all plugins
  node build-plugin-bundles.js -v        # Verbose output
`);
    return;
  }

  buildAllBundles(options);
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { buildAllBundles, createPluginBundle };
